> 具体实现思路

```
// 一、根据占用字节数及求得的二进制补位对应的格式
/**
 * 占用2个字节
 * 010 01110000（根据码点求得的2进制）
 * 110xxxxx 10xxxxxx（补位的格式）
 */
/**
 * 占用3个字节
 * 01001110 00101101（根据码点求得的2进制）
 * 1110xxxx 10xxxxxx 10xxxxxx（补位的格式）
 */
/**
 * 占用4个字节
 * 0101 11000101 10100101（根据码点求得的2进制）
 * 11110xx 10xxxxxx 10xxxxxx 10xxxxxx（补位的格式）
 */
/**
 * 占用5个字节
 * 01 01011110 11000101 10100101（根据码点求得的2进制）
 * 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx（补位的格式）
 */
/**
 * 占用6个字节
 * 0101111 11000101 11000101 10100101（根据码点求得的2进制）
 * 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx（补位的格式）
 */
// 二、通过位运算“&”计算每个字节具体补位数
/**
 * 位运算&时使用,公式:（x & (code >> n)）x的参数参考如下转换，n的参数参考占用字节的转换（第一项）
 * 2=1
 * 3=11
 * 7=111
 * 15=1111
 * 31=11111
 * 63=111111
 * 127=1111111
 */
// 三、位运算“或”来处理每个节点的补位位置
/**
 * 位运算|时使用（第1个字节使用）
 * 00000000
 * 128+64=192=11000000
 * 128+64+32=224=11100000
 * 128+64+32+16=240=11110000
 * 128+64+32+16+8=248=11111000
 * 128+64+32+16+8+4=252=11111100
 * （第2个或2+位字节使用，后续节点都是以10xxxxxx定义的规则）
 * 128=10000000
 */
```
